package ru.job4j.loop;

/**
 * 2. Число-палиндром
 *
 * Число-палиндром - это число, которое читается одинаково слева направо и справа налево, то есть симметричное число. Например, 292 или 5335.
 *
 * Задание: Написать код, который проверяет, является ли входящее число палиндромом (т.е. симметричным), и выводит в консоль "Да", если является,
 * и "Нет", если не является.
 *
 *
 *
 * Существуют разные подходы к решению этой задачи.
 *
 * Например, можно превратить входящее число в строку и начать посимвольное сравнение с обоих концов массива, двигаясь к середине.
 * Если дойдя до середины строки все символы по пути совпали, значит строка является палиндромом. Данное решение имеет недостаток,
 * который заключается в выделении памяти под строку, с которой мы будем работать. В идеале задача должна быть решена с применением
 * постоянного дополнительного пространства (constant extra space), т.е. все дополнительные структуры данных, которые мы выделяем
 * для решения задачи, не должны зависеть от размера входящих данных (т.е. иметь скорость O(1)). Решая задачу этим путём, память
 * под строку выделяется линейно (O(n)), то есть чем больше строка, тем больше под неё будет выделено памяти.
 *
 *
 *
 * Следующий вариант - это инвертировать число и сравнить его со входящим. Если оба числа одинаковые, значит это число-палиндром.
 * Этот вариант тоже имеет подводные камни. Во-первых, при больших значениях входящего числа может выйти так, что когда мы инвертируем
 * входящее число, оно выйдет за пределы диапазона int. Например, было 2_147_483_647, стало 7_463_847_412 - данное число выходит из
 * диапазона, которое может содержать тип int. Во-вторых, палиндром - это симметричное число. Для определения палиндрома достаточно
 * инвертировать только половину числа и сравнить её со второй. Например: число 5335. Инвертируем вторую половину (35 в 53) и сравниваем
 * с первой половиной (53 = 53). Полная инверсия числа является лишней тратой времени и ресурсов и ведёт к снижению производительности.
 *
 *
 *
 * Итак, разобрав самые очевидные решения этой задачи и их недостатки, мы пришли к выводу, что наиболее оптимальным вариантом решения
 * является инверсия одной половины числа и сравнение её со второй, а также выделение постоянного дополнительного пространства вместо
 * непостоянного.
 *
 *
 *
 * Постарайтесь решить упражнение самостоятельно. Если не получится, то можно воспользоваться подсказками по реализации данного алгоритма:
 *
 * - Основная задача здесь - это отделить вторую половину числа. Здесь нам помогут операторы % и /. С помощью выражения number % 10 мы
 * можем вычленить последнюю цифру любого числа, а с помощью выражения number / 10 мы можем "обрезать" последнюю цифру, которую мы
 * только что вычленили с помощью оператора %.
 *
 * - Под хранение значения инвертированной второй половины числа нужно выделить дополнительную переменную. Она здесь и будет являться
 * постоянным дополнительным пространством. Постоянным, потому что независимо от размера входящего числа, мы будем перезаписывать одну
 * и ту же переменную.
 *
 * - Далее нужно в цикле отделять последнее число и перезаписывать доп. переменную, после чего обрезать последнюю цифру в числе и повторять
 * цикл, пока не дойдем до середины числа. Обратите внимание, что так как мы каждый раз обрезаем последнее число делением на 10, то перед
 * его прибавлением к результату мы должны число, сохраненное в доп. переменной, умножить на 10. Например: Из 5335 вычленили 5, осталось 533.
 * Формула прибавки: 10 * 0 (стартовое значение переменной) + 5 = 5. На следующем шаге вычленяем 3, а формула прибавки будет 10 * 5 + 3 = 53.
 * Повторять в цикле до достижения середины числа.
 *
 * - Середина определяется просто: пока входящее число (которое обрезаем на каждом шаге) остаётся больше, чем то, которое мы составляем,
 * значит середина еще не достигнута.
 *
 * - Помните, что количество цифр входящего числа может быть четным и нечетным, поэтому получившая половина и половина, которая осталась,
 * могут быть не равными. Для этого достаточно в финальном сравнении предусмотреть вариант того, что в инвертированную половину может быть
 * записано и центральное число, которое можно не учитывать, так как оно само по себе палиндром, так как находится в центре. Это число можно
 * исключить, добавив помимо сравнения с результатом доп. переменной еще и сравнение с результатом доп. переменной, поделенной на 10, чтобы
 * отсечь центральное число, и сделать подходящим первый или второй вариант.
 */
public class Task174 {

    public static void isPalindrome(int number) {
        int reverted = 0;
        int num = number;
        String rsl = "Нет";
        while (num > reverted) {
            if (number % 10 == 0) {
                break;
            }
            reverted = reverted * 10 + num % 10;
            num /= 10;
        }
        if (num == reverted || num == reverted / 10) {
            rsl = "Да";
        }
        System.out.println(rsl);
    }
}